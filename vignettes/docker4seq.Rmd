---
title: "An Introduction to docker4seq package"
author: "Raffaele A Calogero"
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
The `r Githubpkg("kendomaniac/docker4seq")` package was developed to facilitate the use computing demamding steps in NGS data analysis.

The `r Githubpkg("kendomaniac/docker4seq")` package is the use of docker contaniers that embed demanding computing task as short reads mapping and counting. 
This approach provides multiple advantages: 
*user does not need to install all the software on its local server
*results generated by different containers can be organized in pipelines
*reproducibility is guarantee by the possibility of sharing the docker containers used for the analysis 

## Requirements
The minimal hardware requirements are a 4 core 64 bits linux computer, 32 Gb RAM, one SSD 250GB, with a folder with read/write permission for any users (chmod 777), and [docker](https://www.docker.com/) installed.

**docker4seq** and its graphical interface **4SeqGUI** can fit ideally in the [NUC6I7KYK](https://www.intel.com/content/www/us/en/products/boards-kits/nuc/kits/nuc6i7kyk.html) equipped with Kingston Technology HyperX Impact 32GB Kit (2x16GB), 2133MHz DDR4 CL13 260-Pin SODIMM and Samsung 850 EVO - 250GB - M.2 SATA III Internal SSD.
A ready to go fedora installation USB stick, with everything installed to be used with the above hardware configuration, can be requested at: raffaele.calogero\@unito.it

## Available workflows
At the present time are available the following workflows:

* mirnaCounts executes the workflow described in Cordero et al. PLoS One. 2012;7(2):e31630, which embeds the following steps:
    + trimming adapters with [cutadapt](http://cutadapt.readthedocs.io/en/stable/guide.html)
    + miRNAs mapping on [mirbase](http://www.mirbase.org/) hairpins using [SHRiMP](http://compbio.cs.toronto.edu/shrimp/)
    + quantification of mature miRNAs.
* rnaseqCounts, which allows:
    + adapter trimming with [skewer](https://github.com/relipmoc/skewer)
    + mapping with [STAR](https://github.com/alexdobin/STAR)
    + counting genes and isoforms with [RSEM](http://deweylab.github.io/RSEM/)
    + ENSEMBL gene annotation.
* chipseq, which allows:
    + adapter trimming with [skewer](https://github.com/relipmoc/skewer)
    + mapping with [BWA](http://bio-bwa.sourceforge.net/bwa.shtml)
    + peak calling using either MACS v 1.4 or SICER v 1.1
    + connection of the peak to the nearest gene available in the chosen UCSC genome release,
    + full annotation of the nearest gene.
    

## miRNAseq workflow 

The miRNAseq workflow can be run using **4SeqGUI** graphical interface:
![miRNAseq workflow](/Users/raffaelecalogero/Dropbox/data/docker/docker4seq_devel/docker4seq_devel/inst/img/mirna1.jpeg)
  
  
The miRNAseq docker container executes the following steps:
![miRNAseq workflow](/Users/raffaelecalogero/Dropbox/data/docker/docker4seq_devel/docker4seq_devel/inst/img/mirna3.jpeg)

The full workflow is described in [Cordero et al. Plos ONE 2012](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0031630). In brief, fastq files are trimmed using [cutadapt](https://github.com/marcelm/cutadapt) and the trimmed reads are mapped on miRNA precursors, i.e. harpin.fa file, from [miRBase](http://www.mirbase.org/ftp.shtml) using [SHRIMP](http://compbio.cs.toronto.edu/shrimp/). Using the location of the mature miRNAs in the precursor, countOverlaps function, from the Bioconductor package GenomicRanges is used to quantify the reads mapping on mature miRNAs. 


All the parameters needed to run MACS or SICER can be setup using 4SeqGUI

![miRNAseq parameters](/Users/raffaelecalogero/Dropbox/data/docker/docker4seq_devel/docker4seq_devel/inst/img/mirna2.jpeg)
 
 
A detailed description of the parameters is given below.

### miRNAseq workflow by line command

The miRNAseq workflow can be also executed using R and it is completely embedded in a unique function:

```{r, echo=TRUE, eval=FALSE}
mirnaCounts(group="docker",fastq.folder=getwd(), scratch.folder="/data/scratch", 
            mirbase.id="hsa",download.status=FALSE, adapter.type="NEB", trimmed.fastq=FALSE)
```

Specifically user needs to create the **fastq.folder**, where the fastq.gz files for all miRNAs under analysis are located. 
The **scratch.folder** is the location where temporary data are created. The results will be then saved in the **fastq.folder**.
User needs to provide also the identifier of the miRBase organism, e.g. hsa for Homo sapiens, mmu for Mus musculus.  If the **download.status** is set to FALSE it uses release 21 from miRBase if it is set to TRUE the lastest verison of precursor and mature miRNAs will be downloade dform miRBase. users need to provide the name of the producer of the miRNA library prep kit to identify which adapter need to be provided to cutadapt to remove adapters, **adapter.type** parameter. The available adapters are NEB and Illumina, but, upon request, we can add other adapters. Finally if the **trimmed.fastq** is set to FALSE the trimmed fastq are not saved at the end of the analysis.


### miRNAseq workflow output files

The miRNAseq workflow produces the following output files: 

    + README: A file describing the content of the data folder
    + all.counts.txt: miRNAs raw counts, to be used for differential expression analysis
    + trimmimg.log: adapters trimming statistics
    + shrimp.log: mapping statistics
    + all.counts.Rda: miRNAs raw counts ready to be loaded in R.
    + analysis.log: logs of the full analysis pipeline
    
    
## chipseq workflow

The chipseq workflow can be run using **4SeqGUI** graphical interface:
![ChIPseq workflow](/Users/raffaelecalogero/Dropbox/data/docker/docker4seq_devel/docker4seq_devel/inst/img/chipseq0.jpeg)


The ChIPseq is made of two main steps:

- Creating a genome index for BWA (see end of this paragraph)

- Running MACS or SICER analysis

All the parameters needed to run MACS or SICER can be setup using 4SeqGUI

![MACS and SICER analysis](/Users/raffaelecalogero/Dropbox/data/docker/docker4seq_devel/docker4seq_devel/inst/img/chipseq3.jpeg)


A detailed description of the parameters is given below.

### Chipseq workflow by line command

The chipseq workflow can be also executed using R and it is completely embedded in a unique function:

```{r, echo=TRUE, eval=FALSE}

library(docker4seq)

chipseqCounts(group = c("sudo", "docker"), output.folder = getwd(),
  mock.folder, test.folder, scratch.folder,
  adapter5 = "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT",
  adapter3 = "AATGATACGGCGACCACCGAGATCTACACTCTTTCCCTACACGACGCTCTTCCGATCT",
  threads = 8, min.length = 30, genome.folder,
  mock.id = "igg", test.id = "tf", genome, read.size = 50,
  tool = "macs", macs.min.mfold = 10, macs.max.mfold = 30,
  macs.pval = "1e-5", sicer.wsize = 200, sicer.gsize = 200,
  sicer.fdr = 0.1, tss.distance = 0, max.upstream.distance = 10000,
  remove.duplicates = "N")
```

Specifically user needs to create three folders:

    + mock.folder, where the fastq.gz file for the control sample is located. For control sample we refer to ChIP with IgG only or input DNA.
    + test.folder, where the fastq.gz file for the ChIP of the sample to be analysed.
    + output.folder, where the R script embedding the above script is located.

The **scratch.folder** can be the same as the **output.folder**. However, if the system in use has a high speed disk for temporary calculation, e.g. a SSD disk, the location of the scratch.folder on the SSD will reduce significantly the computing time.

User needs to provide also the sequence of the sequencing adapters, **adapter5** and **adapter3** parameters. In case Illumina platform is used the adapters sequences can be easily recovered [here](https://support.illumina.com/content/dam/illumina-support/documents/documentation/chemistry_documentation/experiment-design/illumina-adapter-sequences_1000000002694-01.pdf). 

**Threads** indicates the max number of cores used by *skewer* and *bwa*, all the other steps are done on a single core.
The **min.length** refers to the minimal length that a reads should have after adapters trimming. Since today the average read length for a ChIP experiment is 50 or 75 nts would be better to bring to 40 nts the min.length parameter to increase the precision in assigning the correct position on the genome.

The **genome.folder** parameter refers to the location of the genomic index generated by bwa using the *docker4seq* function **bwaIndexUcsc**.
The generation of the genome index for ChIP experiment is very simple and it is highlited at the end of this paragraph.

**mock.id** and **test.id** identify the type of sample and are assigned to the ID parameter in the RG field of the bam file.

**genome** is the parameter referring to the annotation used to associate ChIP peaks to genes. In the present implemetation are available hg38, hg19 for human and mm10 and mm9 for mouse annotations.

**read.size** is a parameter requested by MACS and SICER for their analysis. 
**macs.min.mfold**, **macs.max.mfold**, **macs.pval**  are the deafult parameters requested for  peaks definition for more info please refer to the documetation of MACS 1.4.
**sicer.wsize**, **sicer.gsize**, **sicer.fdr** are the deafult parameters requested for  peaks definition for more info please refer to the documetation ofSICER 1.1.
**Important**: The optimal value for **sicer.gsize** in case of H3K4Me3 ChIP is 200 and in case of ChIP H3K27Me3 is 600.   

**tss.distance** and **max.upstream.distance** are parameters required by ChIPseqAnno, which is the bioconducto package used to assign the peaks to specific genes. Specifically max.upstream.distance refers to the max distance in nts that allow to associate a peak to a gene.

**remove.duplicates** is the parameter that indicates if duplicates need to be removed or not. It has two options: **N** duplicates are not removed, **Y** duplicates are removed.


### Chipseq workflow output files

The chipseq workflow produces the following output files: 

    + README: A file describing the content of the data folder
    + mypeaks.xls: All detected peaks alongside the nearest gene and its annotation
    + mytreat.counts: The total reads count for the provided treatment file
    + mycontrol.counts: The total reads count for the provided control/background file
    + peak_report.xls: Aggregate information regarding the peak and their position relative to the nearest gene
    + chromosome_distribution.pdf: Barplot of the distribution of the peaks on the chromosomes
    + relative_position_distribution.pdf: Barplot of the distribution of the peaks positions relative to their nearest gene
    + peak_width_distribution.pdf: Histogram of the distribution of the width of the peaks
    + distance_from_nearest_gene_distribution.pdf: Histogram of the distribution of the distance of each peak from its nearest gene
    + cumulative_coverage_total.pdf: Cumulative normalized gene coverage
    + cumulative_coverage_chrN.pdf: Cumulative normalized gene coverage for the specific chromosome
    + mycontrol_sorted.bw: bigWig file for UCSC Genome Browser visualization
    + mytreat_sorted.bw: bigWig file for UCSC Genome Browser visualization
     



### Creating a BWA index file for Chipseq:

```{r,  echo=TRUE, eval=FALSE}
bwaIndexUcsc(group="sudo",genome.folder="/sto2/data/scratch/hg19_bwa", uscs.urlgenome=
"http://hgdownload.cse.ucsc.edu/goldenPath/mm10/bigZips/chromFa.tar.gz",
gatk=FALSE)
```

In brief, **bwaIndexUcsc** uses UCSC genomic data. User has to provide the URL (**uscs.urlgenome**) for the file chromFa.tar.gz related to the organism of interest and the path to the folder where the index will be generated (**genome.folder**). The parameter **gatk** has to be set to FALSE because is not used for a genomic index used for ChIPseq.

The index can be easily created using the graphical interface:

![Creating a BWA index with Genome indexing BWA](/Users/raffaelecalogero/Dropbox/data/docker/docker4seq_devel/docker4seq_devel/inst/img/chipseq1.jpeg)



